<!doctype html>
<html lang="ru">

<head>
    <!-- Обязательные метатеги -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

    <title>SQL query tree</title>
</head>

<body>
    <img src="img/tree.svg" usemap="#Navigation" class="rounded mx-auto d-block" />
    <p><map id="Navigation" name="Navigation">
            <area shape="rect" coords="308,230,518,265" data-bs-toggle="modal" data-bs-target="#exampleModal" href="">
            <area shape="rect" coords="308,277,518,306" data-bs-toggle="modal" data-bs-target="#exampleModal2" href="">
            <area shape="rect" coords="308,320,518,350" data-bs-toggle="modal" data-bs-target="#exampleModal4" href="">
            <area shape="rect" coords="308,360,518,390" data-bs-toggle="modal" data-bs-target="#exampleModal5" href="">

            <area shape="rect" coords="308,420,518,455" data-bs-toggle="modal" data-bs-target="#exampleModal6" href="">
            <area shape="rect" coords="308,467,518,500" data-bs-toggle="modal" data-bs-target="#exampleModal7" href="">

            <area shape="rect" coords="308,657,518,690" data-bs-toggle="modal" data-bs-target="#exampleModal" href="">
            <area shape="rect" coords="308,700,518,730" data-bs-toggle="modal" data-bs-target="#exampleModal2" href="">
            <area shape="rect" coords="308,737,518,777" data-bs-toggle="modal" data-bs-target="#exampleModal3" href="">
            <area shape="rect" coords="308,783,518,808" data-bs-toggle="modal" data-bs-target="#exampleModal4" href="">
            <area shape="rect" coords="308,812,518,845" data-bs-toggle="modal" data-bs-target="#exampleModal5" href="">

            <area shape="rect" coords="308,875,518,910" data-bs-toggle="modal" data-bs-target="#exampleModal6" href="">
            <area shape="rect" coords="308,920,518,960" data-bs-toggle="modal" data-bs-target="#exampleModal3" href="">
            <area shape="rect" coords="308,970,518,985" data-bs-toggle="modal" data-bs-target="#exampleModal7" href="">

            <area shape="rect" coords="308,1150,518,1187" data-bs-toggle="modal" data-bs-target="#exampleModal2"
                href="">
            <area shape="rect" coords="308,1195,518,1235" data-bs-toggle="modal" data-bs-target="#exampleModal3"
                href="">
            <area shape="rect" coords="308,1243,518,1268" data-bs-toggle="modal" data-bs-target="#exampleModal4"
                href="">
            <area shape="rect" coords="308,1273,518,1300" data-bs-toggle="modal" data-bs-target="#exampleModal5"
                href="">

            <area shape="rect" coords="305,0,417,30" data-bs-toggle="modal" data-bs-target="#exampleModal8" href="">

            <area shape="rect" coords="0,205,121,260" data-bs-toggle="modal" data-bs-target="#exampleModal9" href="">

            <area shape="rect" coords="995,221,1150,280" data-bs-toggle="modal" data-bs-target="#exampleModal10"
                href="">

            <area shape="rect" coords="594,320,716,350" data-bs-toggle="modal" data-bs-target="#exampleModal11" href="">
            <area shape="rect" coords="740,320,860,350" data-bs-toggle="modal" data-bs-target="#exampleModal12" href="">
            <area shape="rect" coords="770,230,880,260" data-bs-toggle="modal" data-bs-target="#exampleModal13" href="">
            <area shape="rect" coords="600,230,710,260" data-bs-toggle="modal" data-bs-target="#exampleModal14" href="">
        </map></p>
    <!-- Кнопка-триггер модального окна -->
    <!--<button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#exampleModal">
        Запустите демо модального окна
    </button>-->

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Имена столбцов</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Значение двух полей из всех записей<br><br>
                    SELECT column1, column2 FROM table;<br><br>
                    Значение всех полей для всех записей<br><br>
                    SELECT * FROM table;<br><br>
                    Только уникальные значение<br><br>
                    SELECT DISTINCT column1 FROM table;<br><br>
                    Сортировка по возрастанию/убыванию<br><br>
                    SELECT * FROM table<br>
                    ORDER BY column1 ASC [DESC];<br><br>
                    Пропустить offset записей и вывести n-записей<br><br>
                    SELECT * FROM table<br>
                    ORDER BY column1<br>
                    LIMIT n OFFSET offset;<br>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal2" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Выражения</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Выражение представляет собой комбинацию одного или нескольких значений,
                    операторов и функций, которые оценивают значение.<br>
                    <br>
                    Функции языка SQL могут быть агрегатными, скалярными и аналитическими.<br>
                    <br>
                    Агрегатные функции выполняют вычисления над группой значений
                    столбца и всегда возвращают одно значение результата этих вычислений.<br>
                    <br>
                    Агрегатные функции: AVG (среднее значение), MIN, MAX, COUNT (подсчет кол-ва), SUM.<br>
                    <br>
                    Скалярная функция выполняет вычисления над одним значением
                    или списком значений.<br>
                    <br>
                    Скалярные функции: ABS, COS, SIN, DEGREES, RADIANS, ROUND,
                    EXP, PI, SQRT, GETDATE, DATENAME, CHAR, LEN, REPLACE, REVERSE<br>
                    <br>
                    Аналитические оконные функции, или функции распределения,
                    предоставляют информацию о распределении данных и используются
                    в основном для статистического анализа.<br>
                    <br>
                    В соответствии со стандартом SQL, аналитические функции вычисляют относительный
                    ранг строки в секции окна, выраженный как дробное число от нуля до единицы,
                    которое большинство воспринимает как процент.<br>
                    Две функции - PERCENT_RANK и CUME_DIST.<br>
                    <br>
                    Функции обратного распределения, более известные под именем процентелей,
                    выполняют вычисление, которое можно считать обратным к функциям
                    распределения рангов.<br>
                    Существует два основных варианта функций обратного
                    распределения: PERCENTILE_DISC и PERCENTILE_CONT.
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal3" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Подзапрос</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Используется, если требуется сравнить результаты нескольких выборок SELECT. Структура подзапроса
                    совпадает со структурой обычного запроса.
                    <br>
                    Запросы бывают коррелированными и некоррелироваными.
                    Коррелированные запросы отличаются от некоррелированных тем, что для каждого
                    столбца из выборки код будет выполняться заново и будет создаваться новое значение.
                    Это очень сильно нагружает процесс, расход времени и памяти.
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal4" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Операторы</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Операторы SQL используются для указания сравнений между выражениями.
                    BETWEEN, B, IS NULL, LIKE.
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal5" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Константы</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    В некоторых инструкциях SQL необходимо указывать значения чисел,
                    строк или даты в текстовом виде. Для этого используется соответствующий
                    тип константы: числовой, строковый или константа даты и время
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal6" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Имена таблиц</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Указание имен таблиц, с которыми будет проводиться работа в запросе.
                    
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal7" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Транспонированные таблицы</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Реляционные операторы PIVOT и UNPIVOT можно использовать для изменения
                    возвращающего табличное значение выражения в другой таблице.PIVOT поворачивает
                    возвращающее табличное значение выражение, преобразуя уникальные значения одного
                    столбца выражения в несколько выходных столбцов. в случае необходимости PIVOT также
                    объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных.
                    UNPIVOT выполняет действия, обратные PIVOT, преобразуя столбцы возвращающего табличное
                    значение в значения столбца.<br><br>
                    <pre>
                    PIVOT(&ltaggregation function>(&ltcolumn being aggregated>)
                        FOR 
                        [&ltcolumn that contains the values that will become column headers>]
                        IN ( [first pivoted column], [second pivoted column],
                        ... [last pivoted column])
                        ) AS &ltalias for the pivot table>
                        &ltoptional ORDER BY clause>;
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal8" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Запрос</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Запрос - это набор команд для работы с базой данных.<br><br>

                    Запросы бывают трех видов. Разберем первый - одиночный запрос к одной таблице.<br><br>

                    Самый простой вариант запроса - это комбинация фраз SELECT и FROM, например: SELECT * FROM
                    table_name;
                    Здесь SELECT, FROM — обязательные элементы запроса, которые определяют выбранные столбцы, их порядок
                    и источник данных. * - выбрать всё.<br><br>

                    Фраза SELECT включает в себя некоторые действия и объекты: выборку столбцов, функции, подзапрос,
                    выражения, операторы, константы и коррелированный подзапрос.
                    Фраза FROM включает в себя: выборку таблиц, подзапрос, коррелированный подзапрос.
                    Если задача требует осуществить запрос с определенным условием, следует использовать фразу WHERE.
                    Она так же включает в себя действия и объекты: выражения, подзапрос, операторы,
                    константы,коррелированный подзапрос и функции.
                    Для более приятного вида таблицу, полученную в результате запроса, можно отсортировать, использовав
                    фразу ORDER BY.
                    Для удобства или по требованию задачи, можно сгруппировать строки полученной таблицы с помощью фразы
                    GROUP BY.
                    Если требуется отфильтровать набор по значениям агрегатных функций, следует использовать фразу
                    HAVING.<br><br>

                    Второй вид запроса - объединение нескольких запросов.<br><br>

                    Используя теоретико-множественные операции UNION, INTERSECT и MINUS мы можем объединить, пересечь
                    или вычесть друг из друга соответственно результаты выборок.<br><br>

                    Третий вид - одиночный запрос к нескольким таблицам.<br><br>

                    С помощью соединения можно получать данные из двух или нескольких таблиц на основе логических связей
                    между ними.<br><br>

                    Четвертый вид - создание некоего подобия временной таблицы.<br><br>

                    Для наглядности приведено дерево, показывающее структуру запроса.<br><br>

                    Теперь рассмотрим раннее упомянутые действия и объекты более подробно в виде схем.<br><br>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal9" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Теоретико-множественные операции</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Объединение выборок UNION:<br><br>

                    <pre>
                SELECT column1, column2 FROM table1
                UNION [ALL]
                SELECT column1, column2 FROM table2;
                    </pre>

                    Пересечение выборок INTERSECT:<br><br>

                    <pre>
                SELECT column1, column2 FROM table1
                INTERSECT
                SELECT column1, column2 FROM table2;
                    </pre>

                    Вычитание выборок MINUS:<br><br>

                    <pre>
                SELECT column1, column2 FROM table1
                MINUS
                SELECT column1, column2 FROM table2;
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal10" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">WITH</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Oracle SQL оператор WITH позволяет дать блоку подзапроса имя/псевдоним, на которое можно
                    ссылаться в нескольких местах основного SQL-запроса. Имя, присвоенное подзапросу, обрабатывается
                    так, как если бы оно было встроенным представлением или таблицей. SQL оператор WITH по сути является
                    заменой обычному подзапросу.<br>
                    Пример WITH с функцией<br><br>
                    <pre>
                    WITH
                    FUNCTION with_function(p_id IN NUMBER) RETURN NUMBER IS
                    BEGIN
                    RETURN p_id;
                    END;
                    SELECT with_function(id)
                    FROM t1
                    WHERE rownum = 1

                    --результат
                    WITH_FUNCTION(ID)
                    </pre>
                    Оператор WITH с рекурсией<br><br>
                    <pre>
                    with numbers(nn) as (
                    select 1 as nn
                    from dual

                    union all

                    select nn+1 as nn
                    from numbers
                    where nn&lt10 ) select * from numbers
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal11" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Внутреннее соединение</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора
                    неважен, поскольку оператор является коммутативным.<br><br>
                    Заголовок таблицы-результата является
                    объединением (конкатенацией) заголовков соединяемых таблиц.<br><br>
                    Тело результата логически формируется следующим образом. Каждая строка одной таблицы сопоставляется
                    с каждой строкой второй таблицы, после чего для полученной «соединённой» строки проверяется условие
                    соединения (вычисляется предикат соединения). Если условие истинно, в таблицу-результат добавляется
                    соответствующая «соединённая» строка.
                    <br><br>
                    <pre>
                    SELECT t1.column1, t2.column2
                    FROM
                    Table1 t1
                    INNER JOIN
                    Table2 t2
                    {ON &ltcondition> | USING (field_name [,... n])}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal12" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Внешние соединения</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Оператор левого внешнего соединения LEFT OUTER JOIN соединяет две таблицы. Порядок таблиц для
                    оператора важен, поскольку оператор не является коммутативным.<br>
                    Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых
                    таблиц.<br>
                    Тело результата логически формируется следующим образом. Пусть выполняется соединение левой и правой
                    таблиц по предикату (условию) p:<br>
                    1. В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату
                    p.<br>
                    2. Затем в результат добавляются те строки левой таблицы, которые не вошли во внутреннее соединение
                    на шаге 1. Для таких строк столбцы, соответствующие правой таблице, заполняются значениями NULL.
                    <br><br>
                    <pre>
                    SELECT t1.column1, t2.column2
                    FROM table1 t1
                    LEFT [OUTER] JOIN table2 t2
                    {ON &ltcondition> | USING (field_name [,... n])}
                </pre>
                    Оператор правого внешнего соединения RIGHT OUTER JOIN соединяет две таблицы. Порядок таблиц для
                    оператора важен, поскольку оператор не является коммутативным.<br>
                    Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых
                    таблиц.<br>
                    Тело результата логически формируется следующим образом. Пусть выполняется соединение левой и правой
                    таблиц по предикату (условию) p:<br>
                    1. В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату
                    p.<br>
                    2. Затем в результат добавляются те строки правой таблицы, которые не вошли во внутреннее соединение
                    на шаге 1. Для таких строк столбцы, соответствующие левой таблице, заполняются значениями NULL.
                    <br><br>
                    <pre>
                    SELECT t1.column1, t2.column2
                    FROM table1 t1
                    RIGHT [OUTER] JOIN table2 t2 
                    {ON &ltcondition> | USING (field_name [,... n])}
                    </pre>
                    Оператор полного внешнего соединения FULL OUTER JOIN соединяет две таблицы. Порядок таблиц для
                    оператора неважен, поскольку оператор является коммутативным.<br>
                    Соединяет таблицы аналогично левому и правому внешнему соединению вместе взятых.<br><br>
                    <pre>
                    SELECT t1.column1, t2.column2
                    FROM table1 t1
                    RIGHT [OUTER] JOIN table2 table2
                    {ON &ltcondition> | USING (field_name [,... n])}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal14" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">Перекрестное соединение</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    Оператор перекрёстного соединения, или декартова произведения CROSS JOIN соединяет две таблицы.
                    Порядок таблиц для оператора неважен, поскольку оператор является коммутативным.<br>
                    Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых
                    таблиц.<br>
                    Тело результата логически формируется следующим образом. Каждая строка одной таблицы соединяется с
                    каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух
                    таблиц.<br><br>
                    <pre>
                    SELECT t1.column1, t2.column2
                    FROM table1 t1
                    CROSS JOIN table2 t2
                    {ON &ltcondition> | USING (field_name [,... n])}
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно -->
    <div class="modal fade" id="exampleModal13" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">С условиями соединения</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
                </div>
                <div class="modal-body">
                    При эквисоединении (equi-join) две или более таблиц соединяются на основании условия равенства между
                    столбцами. Другими словами, один и тот же столбец имеет одинаковое значение во всех соединяемых
                    таблицах. Ниже приведен пример применения эквисоединения:<br><br>
                    <pre>
                    SELECT e.last_name, d.dept
                    FROM emp e, dept d WHERE e.emp_id = d.emp_id;
                </pre>
                    Под рефлексивным соединением (self join) подразумевается соединение таблицы с самой собой за счет
                    использования псевдонимов. В следующем примере осуществляется соединение таблицы employees с самой
                    собой при помощи псевдонима с удалением всех дублированных строк.<br><br>
                    <pre>
                    DELETE FROM employees X WHERE ROWID >
                    (select MIN(rowid) FROM employees Y
                    where X.key_values = Y.key_values);
                </pre>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>
</body>

</html>